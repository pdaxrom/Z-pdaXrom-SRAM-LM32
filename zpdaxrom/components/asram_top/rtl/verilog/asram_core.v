//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.  
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user’s design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                        FILE DETAILS
// Project          : Async SRAM Controller
// File             : asram_core.v
// Title            : Asynchronous SRAM Controller
// Dependencies     : asram_params.v
// Description      : Implements the logic to interface async SRAM with Wishbone
//                    bus.
// ==============================================================================
//                        REVISION HISTORY
// Version          : 7.0
// Mod. Date        : Jun 27, 2005
// Changes Made     : Initial Creation
//
// Version          : 7.0SP2, 3.0
// Mod. Date        : 27 Sept. 2007
// Changes Made     : Endianess corrections, and full support for 8 and 16-bit
//                    operational modes.
//
// Version          : D1.2, 3.1
// Mod. Data        : 30 Nov. 2010
// Changes          : 1. Support for 8 and 32 WISHBONE data busses.
//                    2. Support for registered WISHBONE data output.
//                    3. Fixed bug that did not increment SRAM address on burst
//                       writes by deasserting WEN.
// ==============================================================================
`ifndef ASRAM_CORE_FILE
 `define ASRAM_CORE_FILE
 `include "system_conf.v"

module asram_core
  #(parameter WB_DAT_WIDTH    = 32,
    parameter SRAM_DATA_WIDTH = 32,
    parameter SRAM_ADDR_WIDTH = 32,
    parameter SRAM_BE_WIDTH   = 4,
    parameter READ_LATENCY    = 1,
    parameter WRITE_LATENCY   = 1,
    parameter DATA_OUTPUT_REG = 0
    )
   (
    input clk_i,
    input rst_i,
    
    // WISHBONE
    input cyc_i,
    input stb_i,
    input [2:0] cti_i,
    input [1:0] bte_i,
    input [31:0] addr_i,
    input [WB_DAT_WIDTH-1:0] dat_i,
    input [WB_DAT_WIDTH/8-1:0] sel_i,
    input we_i,
    output reg ack_o,
    output [WB_DAT_WIDTH-1:0] dat_o,
    
    // SRAM
    output reg [SRAM_ADDR_WIDTH-1:0] sram_addr,
    output reg [SRAM_DATA_WIDTH-1:0] sram_data_out,
    output reg [SRAM_BE_WIDTH-1:0] sram_be,
    output reg sram_csn,
    output reg sram_oen,
    output reg sram_wen,
    input [SRAM_DATA_WIDTH-1:0] sram_data_in
    );
   
   wire [1:0]  cycle;
   
   reg [SRAM_ADDR_WIDTH-1:0] sram_addr_nxt;
   reg [SRAM_DATA_WIDTH-1:0] sram_data_out_nxt;
   reg [SRAM_BE_WIDTH-1:0]   sram_be_nxt;
   reg [WB_DAT_WIDTH-1:0]    tmp_dat_o, tmp_dat_o_nxt;
   reg 			     tmp_ack_o, tmp_ack_o_nxt;
   reg [3:0] 		     dly, dly_nxt, latency;
   reg [1:0] 		     acycle, cycle_counter, cycle_counter_nxt;
   
   reg [1:0] state, state_nxt;
   parameter SM_IDLE = 2'b00;
   parameter SM_BUSY = 2'b01;
   parameter SM_WAIT = 2'b10;
   
   always @(/*AUTOSENSE*/ack_o or cti_i or cyc_i or cycle or dly
	    or state or stb_i or we_i)
     casez (state)
       SM_IDLE:
	 if (cyc_i && stb_i && (ack_o == 1'b0))
	   state_nxt = SM_BUSY;
	 else
	   state_nxt = state;
       
       SM_BUSY:
	 if ((dly == 1) && (cycle == 0) && ((cti_i == 3'b000) || (cti_i == 3'b111)))
	   state_nxt = SM_IDLE;
	 else if ((we_i && (dly == 1))
		  || ((we_i == 0) && (dly == 1) && (cycle == 0) && (cti_i == 3'b010)))
	   state_nxt = SM_WAIT;
	 else
	   state_nxt = state;
       
       SM_WAIT:
	 if ((cycle != 0) || (stb_i && (ack_o == 1'b0)))
	   state_nxt = SM_BUSY;
	 else
	   state_nxt = state;
              
       default:
	 state_nxt = SM_IDLE;
     endcase
   
   /*----------------------------------------------------------------------
    Compute Delay (the time required to complete an SRAM access)
    ----------------------------------------------------------------------*/
   always @(/*AUTOSENSE*/cycle or dly or state or we_i)
     begin
	if ((state == SM_IDLE) || (state == SM_WAIT))
	  dly_nxt = we_i ? WRITE_LATENCY : READ_LATENCY;
	else if ((dly == 1) && (cycle > 0) && (we_i == 1'b0) && (state == SM_BUSY))
	  dly_nxt = READ_LATENCY;
	else if (state == SM_BUSY)
	  dly_nxt = dly - 1'b1;
	else
	  dly_nxt = dly;
     end
   
   /*----------------------------------------------------------------------
    Sequential logic
    ----------------------------------------------------------------------*/
   always @(posedge clk_i or posedge rst_i)
     if (rst_i) begin
	state <= #1 SM_IDLE;
	dly <= #1 4'b0000;
     end
     else begin
	state <= #1 state_nxt;
	dly <= #1 dly_nxt;
     end
      
   /*----------------------------------------------------------------------
    A WISHBONE access can result in multiple SRAM accesses depending on the
    size of WISHBONE and SRAM data busses.
    ----------------------------------------------------------------------*/
   generate
      
      if (WB_DAT_WIDTH <= SRAM_DATA_WIDTH) begin
	 
	 assign cycle = 2'b00;
	 
      end
      else begin
	 
	 if (SRAM_DATA_WIDTH == 8) begin
	    
	    always @(/*AUTOSENSE*/sel_i)
	      acycle = (((sel_i == 4'b0001) || (sel_i == 4'b0010) || (sel_i == 4'b0100) || (sel_i == 4'b1000))
			? 2'b00
			: (((sel_i == 4'b0011) || (sel_i == 4'b1100))
			   ? 2'b01
			   : 2'b11));
	    
	 end
	 else begin
	    
	    always @(/*AUTOSENSE*/sel_i)
	      acycle = (sel_i == 4'b1111) ? 2'b01 : 2'b00;
	    
	 end
	 
	 always @(/*AUTOSENSE*/ack_o or acycle or cycle
		  or cycle_counter or dly or state or stb_i or we_i)
	   if ((state == SM_IDLE) || ((state == SM_WAIT) && (cycle == 0) && stb_i && (ack_o == 1'b0)))
	     cycle_counter_nxt = acycle;
	   else if (((state == SM_WAIT) && (cycle != 0))
		    || ((state == SM_BUSY) && (we_i == 1'b0) && (dly == 1) && (cycle > 0)))
	     cycle_counter_nxt = cycle_counter - 1'b1;
	   else
	     cycle_counter_nxt = cycle_counter;
	 
	 always @(posedge clk_i or posedge rst_i)
	   if (rst_i)
	     cycle_counter <= #1 2'b00;
	   else
	     cycle_counter <= #1 cycle_counter_nxt;
	 
	 assign cycle = cycle_counter;
	 
      end
      
   endgenerate

   /*----------------------------------------------------------------------
    SRAM signals
    ----------------------------------------------------------------------*/
   always @(/*AUTOSENSE*/cyc_i or state or we_i)
     begin
	sram_csn = ~(state == SM_BUSY);
	sram_oen = ~((state == SM_BUSY) && ~we_i);
	sram_wen = ~(cyc_i && we_i && (state == SM_BUSY));
     end
   
   generate
      
      if (WB_DAT_WIDTH == 8) begin
	 
	 case (SRAM_DATA_WIDTH)
	   8: begin
	      
	      always @(/*AUTOSENSE*/addr_i or cyc_i or dat_i)
		begin
		   sram_addr_nxt = addr_i[SRAM_ADDR_WIDTH-1:0];
		   sram_be_nxt = ~cyc_i;
		   sram_data_out_nxt = dat_i;
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 1'b1;
		   sram_data_out <= #1 8'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	   16: begin
	      
	      always @(/*AUTOSENSE*/addr_i or dat_i)
		begin
		   sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:1], 1'b0};
		   sram_be_nxt = addr_i[0] ? 2'b10 : 2'b01;
		   sram_data_out_nxt = addr_i[0] ? {8'b0, dat_i} : {dat_i, 8'b0};
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 2'b11;
		   sram_data_out <= #1 16'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	   default: begin
	      
	      always @(/*AUTOSENSE*/addr_i or dat_i)
		begin
		   sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b00};
		   sram_be_nxt = ((addr_i[1:0] == 2'b00) 
				  ? 4'b0111
				  : ((addr_i[1:0] == 2'b01) 
				     ? 4'b1011
				     : ((addr_i[1:0] == 2'b10)
					? 4'b1101
					: 4'b1110)));
		   sram_data_out_nxt = ((addr_i[1:0] == 2'b00) 
					? {dat_i, 24'b0} 
					: ((addr_i[1:0] == 2'b01) 
					   ? {8'b0, dat_i, 16'b0} 
					   : ((addr_i[1:0] == 2'b10)
					      ? {16'b0, dat_i, 8'b0}
					      : {24'b0, dat_i})));
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 4'b1111;
		   sram_data_out <= #1 32'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	 endcase
	 
      end
      else begin
	 
	 case (SRAM_DATA_WIDTH)
	   8: begin
	      
	      always @(/*AUTOSENSE*/ack_o or addr_i or cycle or dat_i
		       or dly or sel_i or sram_addr or sram_data_out
		       or state or stb_i or we_i)
		begin
		   if ((state == SM_IDLE)
		       || (stb_i && (ack_o == 1'b0) && (cycle == 0) && (state == SM_WAIT)))
		     sram_addr_nxt = addr_i[SRAM_ADDR_WIDTH-1:0];
		   else 
		     if (((state == SM_WAIT) && (cycle != 0))
			 || ((state == SM_BUSY) && (we_i == 1'b0) && (dly == 1) && (cycle != 0)))
		       if (sel_i == 4'b1111)
			 sram_addr_nxt = ((cycle == 3)
					  ? {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b01}
					  : ((cycle == 2)
					     ? {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b10}
					     : {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b11}));
		       else 
			 sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:1], 1'b1};
		     else
		       sram_addr_nxt = sram_addr;
		   
		   sram_be_nxt = 1'b0;
		   if ((sel_i == 4'b0001)
		       || (((sel_i == 4'b0011) || (sel_i == 4'b1111)) && (cycle == 1) && (state == SM_WAIT)))
		     sram_data_out_nxt = dat_i[7:0];
		   else if ((sel_i == 4'b0010)
			    || (stb_i && (ack_o == 1'b0) && (sel_i == 4'b0011) && ((state == SM_IDLE) || (state == SM_WAIT)))
			    || ((sel_i == 4'b1111) && (cycle == 2) && (state == SM_WAIT)))
		     sram_data_out_nxt = dat_i[15:8];
		   else if ((sel_i == 4'b0100)
			    || ((sel_i == 4'b1100) && (cycle == 1) && (state == SM_WAIT))
			    || ((sel_i == 4'b1111) && (cycle == 3) && (state == SM_WAIT)))
		     sram_data_out_nxt = dat_i[23:16];
		   else if ((sel_i == 4'b1000)
			    || (stb_i && (ack_o == 1'b0) && ((sel_i == 4'b1100) || (sel_i == 4'b1111)) && ((state == SM_IDLE) || ((cycle == 0) && (state == SM_WAIT)))))
		     sram_data_out_nxt = dat_i[31:24];
		   else
		     sram_data_out_nxt = sram_data_out;
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 1'b1;
		   sram_data_out <= #1 8'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	   16: begin
	      
	      always @(/*AUTOSENSE*/ack_o or addr_i or cycle or dat_i
		       or dly or sel_i or sram_addr or sram_data_out
		       or state or stb_i or we_i)
		begin
		   if ((state == SM_IDLE)
		       || (stb_i && (ack_o == 1'b0) && (cycle == 0) && (state == SM_WAIT)))
		     sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:1],1'b0};
		   else
		     if (((state == SM_WAIT) && (cycle == 1))
			 || ((state == SM_BUSY) && (we_i == 1'b0) && (dly == 1) && (cycle == 1)))
		       sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b10};
		     else
		       sram_addr_nxt = sram_addr;
		   
		   if (sel_i == 4'b1111) begin
		      sram_be_nxt = 2'b00;
		      
		      if (stb_i 
			  && (ack_o == 1'b0) 
			  && ((state == SM_IDLE) 
			      || ((cycle == 0) && (state == SM_WAIT))))
			sram_data_out_nxt = dat_i[31:16];
		      else if ((cycle == 1) && (state == SM_WAIT))
			sram_data_out_nxt = dat_i[15:0];
		      else
			sram_data_out_nxt = sram_data_out;
		   end
		   else 
		     if (sel_i[1:0] == 2'b00) begin
			sram_be_nxt = ~sel_i[3:2];
			sram_data_out_nxt = dat_i[31:16];
		     end
		     else begin
			sram_be_nxt = ~sel_i[1:0];
			sram_data_out_nxt = dat_i[15:0];
		     end
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 2'b11;
		   sram_data_out <= #1 16'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	   default: begin
	      
	      always @(/*AUTOSENSE*/ack_o or addr_i or dat_i or sel_i
		       or sram_addr or state or stb_i)
		begin
		   if ((state == SM_IDLE)
		       || (stb_i && (ack_o == 1'b0) && (state == SM_WAIT)))
		     sram_addr_nxt = {addr_i[SRAM_ADDR_WIDTH-1:2], 2'b00};
		   else
		     sram_addr_nxt = sram_addr;
		   
		   sram_be_nxt = ~sel_i;
		   sram_data_out_nxt = dat_i[31:0];
		end
	      
	      always @(posedge clk_i or posedge rst_i)
		if (rst_i) begin
		   sram_addr <= #1 0;
		   sram_be <= #1 4'b1111;
		   sram_data_out <= #1 32'b0;
		end
		else begin
		   sram_addr <= #1 sram_addr_nxt;
		   sram_be <= #1 sram_be_nxt;
		   sram_data_out <= #1 sram_data_out_nxt;
		end
	      
	   end
	 endcase
	 
      end
      
   endgenerate
      
   /*----------------------------------------------------------------------
    Return data on WISHBONE
    ----------------------------------------------------------------------*/
   generate
      
      if (WB_DAT_WIDTH == 8) begin
	 
	 case (SRAM_DATA_WIDTH)
	   8: begin
	      
	      always @(/*AUTOSENSE*/dly or sram_data_in or state
		       or tmp_dat_o)
		if ((state == SM_BUSY) && (dly == 1))
		  tmp_dat_o_nxt = sram_data_in;
		else
		  tmp_dat_o_nxt = tmp_dat_o;
	      
	   end
	   16: begin
	      
	      always @(/*AUTOSENSE*/addr_i or dly or sram_data_in
		       or state or tmp_dat_o)
		if ((state == SM_BUSY) && (dly == 1))
		  tmp_dat_o_nxt = addr_i[0] ? sram_data_in[7:0] : sram_data_in[15:8];
		else
		  tmp_dat_o_nxt = tmp_dat_o;
	      	      
	   end
	   default: begin
	      
	      always @(/*AUTOSENSE*/addr_i or dly or sram_data_in
		       or state)
		begin
		   if ((state == SM_BUSY) && (dly == 1))
		     casez (addr_i[1:0])
		       2'b00: tmp_dat_o_nxt = sram_data_in[31:24];
		       2'b01: tmp_dat_o_nxt = sram_data_in[23:16];
		       2'b10: tmp_dat_o_nxt = sram_data_in[15: 8];
		       2'b11: tmp_dat_o_nxt = sram_data_in[ 7: 0];
		       default:
			 tmp_dat_o_nxt = 8'b0;
		     endcase
		   else
		     tmp_dat_o_nxt = 8'b0;
		end
	      
	   end
	 endcase
	 
	 always @(posedge clk_i or posedge rst_i)
	   if (rst_i)
	     tmp_dat_o <= #1 8'b0;
	   else
	     tmp_dat_o <= #1 tmp_dat_o_nxt;
	 
	 if (DATA_OUTPUT_REG == 1) 
	   assign dat_o = tmp_dat_o;
	 else
	   assign dat_o = tmp_dat_o_nxt;
	 
      end
      else begin
	 
	 case (SRAM_DATA_WIDTH)
	   8: begin
	      	      
	      always @(/*AUTOSENSE*/cycle or dly or sel_i
		       or sram_data_in or state or tmp_dat_o)
		begin
		   if ((state == SM_BUSY) && (dly == 1))
		     if (sel_i == 4'b1111)
		       casez (cycle)
			 2'b11: tmp_dat_o_nxt = {                  sram_data_in, tmp_dat_o[23:0]};
			 2'b10: tmp_dat_o_nxt = {tmp_dat_o[31:24], sram_data_in, tmp_dat_o[15:0]};
			 2'b01: tmp_dat_o_nxt = {tmp_dat_o[31:16], sram_data_in, tmp_dat_o[ 7:0]};
			 2'b00: tmp_dat_o_nxt = {tmp_dat_o[31: 8], sram_data_in                 };
			 default: 
			   tmp_dat_o_nxt = 32'b0;
		       endcase
		     else if (sel_i == 4'b1100)
		       if (cycle == 2'b00)
			 tmp_dat_o_nxt = {tmp_dat_o[31:24], sram_data_in, 16'b0};
		       else
			 tmp_dat_o_nxt = {sram_data_in, tmp_dat_o[23:16], 16'b0};
		     else if (sel_i == 4'b0011)
		       if (cycle == 2'b00)
			 tmp_dat_o_nxt = {16'b0, tmp_dat_o[31:24], sram_data_in};
		       else
			 tmp_dat_o_nxt = {16'b0, sram_data_in, tmp_dat_o[23:16]};
		     else
		       casez (sel_i)
			 4'b0001: tmp_dat_o_nxt = {24'b0, sram_data_in       };
			 4'b0010: tmp_dat_o_nxt = {16'b0, sram_data_in,  8'b0};
			 4'b0100: tmp_dat_o_nxt = { 8'b0, sram_data_in, 16'b0};
			 4'b1000: tmp_dat_o_nxt = {       sram_data_in, 24'b0};
			 default:
			   tmp_dat_o_nxt = 32'b0;
		       endcase
		   else
		     tmp_dat_o_nxt = tmp_dat_o;
		end
	      
	   end
	   16: begin
	      
	      always @(/*AUTOSENSE*/cycle or dly or sel_i
		       or sram_data_in or state or tmp_dat_o)
		begin
		   if ((state == SM_BUSY) && (dly == 1))
		     if (sel_i == 4'b1111)
		       casez (cycle)
			 2'b01: tmp_dat_o_nxt = {                  sram_data_in, tmp_dat_o[15:0]};
			 2'b00: tmp_dat_o_nxt = {tmp_dat_o[31:16], sram_data_in                 };
			 default:
			   tmp_dat_o_nxt = 32'b0;
		       endcase
		     else if ((sel_i == 4'b1100) || (sel_i == 4'b1000) || (sel_i == 4'b0100))
		       tmp_dat_o_nxt = {sram_data_in, 16'b0};
		     else if ((sel_i == 4'b0011) || (sel_i == 4'b0010) || (sel_i == 4'b0001))
		       tmp_dat_o_nxt = {16'b0, sram_data_in};
		     else
		       tmp_dat_o_nxt = tmp_dat_o;
		end
	      
	   end
	   default: begin
	      
	      always @(/*AUTOSENSE*/dly or sram_data_in or state
		       or tmp_dat_o)
		if ((state == SM_BUSY) && (dly == 1))
		  tmp_dat_o_nxt = sram_data_in;
		else
		  tmp_dat_o_nxt = tmp_dat_o;
	      
	   end
	 endcase
	 
	 always @(posedge clk_i or posedge rst_i)
	   if (rst_i)
	     tmp_dat_o <= #1 32'b0;
	   else
	     tmp_dat_o <= #1 tmp_dat_o_nxt;
	 
	 if (DATA_OUTPUT_REG == 1) 
	   assign dat_o = tmp_dat_o;
	 else
	   assign dat_o = tmp_dat_o_nxt;
	 
      end
      
   endgenerate
      
   
   /*----------------------------------------------------------------------
    WISHBONE ACK
    ----------------------------------------------------------------------*/
   always @(/*AUTOSENSE*/we_i)
     latency = we_i ? WRITE_LATENCY : READ_LATENCY;
   
   generate
      
      if (WB_DAT_WIDTH <= SRAM_DATA_WIDTH) begin
	 
	 always @(/*AUTOSENSE*/ack_o or cyc_i or dly or latency
		  or state or stb_i)
	   begin
	      if (((latency == 1)
		   && (((state == SM_IDLE) && cyc_i && stb_i && (ack_o == 1'b0))
		       || ((state == SM_WAIT) && stb_i && (ack_o == 1'b0))))
		  || ((latency > 1) && (dly == 2) && (state == SM_BUSY)))
		tmp_ack_o_nxt = 1'b1;
	      else
		tmp_ack_o_nxt = 1'b0;
	      
	   end
	 
      end
      else begin
	 
	 always @(/*AUTOSENSE*/ack_o or acycle or cyc_i or cycle
		  or dly or latency or state or stb_i or we_i)
	   begin
	      if (((latency > 1) 
		   && (dly == 2) && (cycle == 0) && (state == SM_BUSY))
		  || ((latency == 1)
		      && (acycle == 0)
		      && cyc_i && stb_i && (ack_o == 1'b0) 
		      && ((state == SM_IDLE) || (state == SM_WAIT)))
		  || ((latency == 1) 
		      && (acycle > 0) 
		      && (cycle == 1) 
		      && (((state == SM_WAIT) && we_i )
			  || ((state == SM_BUSY) && (we_i == 1'b0)))))
		tmp_ack_o_nxt = 1'b1;
	      else
		tmp_ack_o_nxt = 1'b0;
	   end
	 
      end
      
      always @(posedge clk_i or posedge rst_i)
	if (rst_i)
	  tmp_ack_o <= #1 1'b0;
	else
	  tmp_ack_o <= #1 tmp_ack_o_nxt;
      
      if (DATA_OUTPUT_REG == 1) begin
	 
	 reg tmp_ack_o_d;
	 always @(posedge clk_i or posedge rst_i)
	   if (rst_i)
	     tmp_ack_o_d <= #1 1'b0;
	   else
	     tmp_ack_o_d <= #1 tmp_ack_o;
	 
	 always @(/*AUTOSENSE*/tmp_ack_o or tmp_ack_o_d or we_i)
	   ack_o = we_i ? tmp_ack_o : tmp_ack_o_d;
	 
      end
      else begin
	 
	 always @(/*AUTOSENSE*/tmp_ack_o)
	   ack_o = tmp_ack_o;
	 
      end
      
   endgenerate
   
endmodule
`endif // ASRAM_CORE_FILE
